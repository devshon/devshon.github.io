---
layout: single
title: "숨고 클론 프로젝트 회고록"
categories: Story
tag: [total]
---

# 1시작하기 앞서

위코드에서 진행한 **숨고** 사이트 클론 프로젝트 입니다.

자세한 소개와 저장소는 [여기서](https://github.com/wecode-bootcamp-korea/justcode-4-1st-omm-front) 확인할 수 있습니다.

### 숨고란

> '숨은 고수'의 준말, 숨고는 (주)브레이브모바일에서 2015년부터 서비스 중인 전문가 매칭 서비스 플랫폼이다.
>
> 숨고는 홈페이지 혹은 어플리케이션으로 접속하여 간단한 요청서를 작성하면 숨은 고수(전문가)들 다수의 고수에게 견적서를 각각 받아 고수를 비교 선택할 수 있다.

### 소개

> **목표**
> React, Node, MySQL 을 활용한 개발 프로젝트
>
> **기간**
> 2022-03-28 ~ 2022-04-08
>
> **팀원**
> 손성호(me), 김연주, 이택우, 설혜원, 마승우
>
> **포지션**
> 백엔드(1), 프론트(2), 풀스택(2)

### 스킬

> **프론트엔드**
> React, Javascript, sass, module css
>
> **백엔드**
> Node, Express, MySQL, bcrypt, jsonwebtoken, prisma, cors
>
> **툴 & 스킬**
> RESTful API, MVC Pattern, Github, Slack, Notion, DBdiagrams, Figma

# 2프로젝트 관리

> 프로젝트의 방향성과 중심은 기획/설계라 생각하여 프로젝트 관리에도 적지 않은 시간을 들였습니다.

### 팀 노션

> 팀원들과 노션을 사용하여 프로젝트 진행과, 레퍼런스, 진행방식 (컨벤션, 스키마, 시그니처 etc...) 등 을 기록했습니다.

![screencapture-9664296](/images/screencapture-9664296.png)

### 테이블 설계도

> 타입이 2개인 유저의 특징을 고려하여 일반 유저, 고수 유저를 중심으로 테이블을 만들어 나갔습니다.
>
> 개발기간이 적어서 개발중에 테이블이 생성 되거나 불필요한 정보가 삭제되는 일이 있었지만, 최신화를 항상 유지 하였습니다.

![screencapture-9663363](/images/screencapture-9663363.png)

### 화면 설계도

> 기획/설계가 필요없는 클론 프로젝트였지만, 초반에 서비스를 이해하는 시간이 부족하여 필요한 화면과 그것의 역할을 명확하게 명시하고 분담 했습니다.

![screencapture-9663268](/images/screencapture-9663268.png)

### 미팅

> 데일리 미팅과 스프린트 미팅을 주단위로 실행 했습니다.
>
> 매일 팀원들과 일정 상황을 체크하여 해야할 일에 대해서 명확해지는 점이 좋았습니다.
>
> 스프린트 미팅을 해서 뒤쳐지는 팀원들이 묻히지 않고 팀원들과 조율하여 역할을 재분배 하는 과정에서 협업이란 것을 몸으로 느낀 것 같습니다.

![screencapture-9664653](/images/screencapture-9664653.png)

### 형상관리

> 이전에도 개발은 해봤지만 이번 프로젝트를 통해서 Github를 왜 사용하는지 몸으로 느꼈습니다..!
>
> PR과 Branch의 철저한 관리로 나의 코드만 알고 넘어가는 것이 아닌 모두의 코드, 한마디로 개발 과정을 내 머릿속에 계속 업데이트 할 수 있었습니다.
>
> 깃허브를 연동한 슬랙과 깃허브에게 감사의 말씀 전달합니다.

![screencapture-9664945](/images/screencapture-9664945.png)

# 3팀에서의 역할

> 이번 프로젝트에서 저의 **공식적인** 역할은 풀스택 이였습니다.
>
> 풀스택을 선택한 이유는 전체적인 프로젝트의 흐름을 가져가고 싶었습니다.
>
> 또한 먼 훗날 프로젝트를 총괄하는 역할을 맡게 된다면 모든 분야에 지식을 갖고 있어야 된다고 생각 했습니다.
>
> 저의 **비공식적인** 역할은 프로젝트 관리 이였습니다.
>
> 매일 특이사항을 전달하고, 최신화를 유지하고, 일정에 차질이 없게 진행하고 싶었습니다.
>
> 다행이 마음 좋은 팀원들이 받아 주었던 것 같습니다..어쩌면 자기주장적 이고 못 미더웠을 수 있었을 텐데 의지도 하고 서로 격려와 응원을 해주면서 잘 마무리 했던 것 같네요.

### 고수찾기 리스트 페이지 & 필터 API

> 고수찾기 리스트 페이지는 크게 2가지 컴포넌트로 나뉘어져 있습니다.
>
> 필터기능이 있는 **MasterListHeader (헤더)** 컴포넌트 와 리스트가 출력되 는 **MasterListContents (컨텐츠)** 컴포넌트 입니다.
>
> 헤더 컴포넌트는 필터링 기능을 위한 상태변수가 많기 때문에 상태값과 연관 없는 렌더링을 지양하기 위해서 컨텐츠 컴포넌트와 분리 하였습니다.
>
> 컨텐츠 컴포넌트는 **MasterItem (아이템)** 이라는 하위 컴포넌트를 `map` 함수를 사용하여 컴포넌트를 한번 더 분리 하였습니다.
>
> 헤더 컴포넌트는 필터기능으로 상태값이 변경되면 `useEffect` 훅을 재호출 하여 Query Parameter 로 선택한 카테고리/지역의 `id` 값을 전달하고 처음 페이지를 들어올 때 호출되는 쿼리문에 `id` 값을 조건문으로 추가하여 다시 클라이언트로 반환 해줍니다.

![search](/images/search.gif)

### 리스트 페이지 무한 스크롤

> prisma 자료를 찾다가 `take` 라는 조건을 알게되었습니다.
>
> 일단, 클라이언트에서 스크롤이 하단에 닿게 되면 이벤트가 호출되게 하였습니다.
>
> window의 공식 함수인 `addEventListener` 를 사용 했습니다.
>
> 사용하기 앞서, `useEffect` 훅 내부에 선언하고 훅 내부에 `return` 함수를 만들어서 해당 페이지를 벗어나면 `removeEventListener` 함수로 호출했던 이벤트를 해제하게 하였습니다.
>
> 스크롤 이벤트를 선언하고 콜백 함수를 만들어서 이벤트를 넘겨받습니다.
>
> 이벤트의 `scrollHeight`, `scrollTop`, `clientHeight` 값을 사용하여 스크롤이 페이지 하단에 닿을때를 나타낼 수 있는 공식을 조건문에 담아서 상태변수에 보여줄 리스트 갯수만큼 수를 더합니다.
>
> 보여줄 리스트가 수가 담긴 상태값이 변경 되었으니 dept에 변수를 담은 `useEffect` 훅을 재 실행하고 리스트 개수가 추가되어 반환 합니다.
>
> 추가적으로 하단을 찍었을 때 Loading 이벤트가 생기게 하기 위해서 `Boolean` 값 상태변수를 선언하여 스크롤이 닿을 때 Loading 바를 나타나게 하고, 밑으로 `setTimeout` 함수를 사용해서 0.5초 뒤에 함수가 실행하게 하고 리스트 개수가 추가되는 상태변수가 이때 개수를 추가하고 동시에 `Loading` 바는 사라지게 했습니다.

![masterlist](/images/masterlist.gif)

### 고수 프로필 페이지

> 자신의 고수 정보를 수정하는 기능을 담당하고 있습니다.
>
> 아래 화면을 보면 각각의 정보는 다른 정보와 연관성이 없어서 각각의 정보를 각각의 컴포넌트로 나눴습니다.
>
> 하지만 각각의 정보가 동일한 부분이 하나 있다면 정보의 타이틀 (ex: 대표 서비스, 한줄 소개) 과 버튼 (수정, 등록하기, 등록) 들을 공통의 컴포넌트로 나눴습니다.
>
> 쉽게 설명하면 컴포넌트의 관계는 **MasterProfile (page)** > **MasterProfileName (compo_1)** > **MasterProfileTitle (compo_2)** 로 나눠 있습니다.
>
> page 내부에 각각의 정보 컴포넌트를 줄줄이 담고 각각의 정보 컴포넌트 내부에서 공통의 타이틀과 버튼 부분을 `props.children` 을 사용하여 compo_2에 담았습니다.
>
> 변경된 정보의 상태값은 각각의 컴포넌트에서 관리되며 버튼(등록) 을 클릭 했을 때 서버로 전송 합니다.

![profile](/images/profile.gif)

### 반응형 웹

> 웹에서 중요한 부분 중 하나라고 생각합니다.
>
> 모바일을 호환할 수 있으며, 웹 사이트의 퀄리티를 높혀준다고 생각합니다.
>
> 실제 사용자가 사용한다고 가정했을 때 부드러운 반응형과 모바일웹 화면에서는 사용자의 터치 영역을 고려한다면 퀄리티 있는 웹이 아닐까 생각하고 만들었습니다.
>
> 부드러운 반응형을 보이기 위해 팀 내에서 반응형 사이즈를 공통으로 정하여 사용 했습니다.

![media01](/images/media01.gif)

![media02](/images/media02.gif)

# 4기억에 남는 코드

> 제가 선정한 기억에 남는 코드의 기준은 가독성이 좋으며 중복이 없고 난잡해질 수 있는 코드를 깔끔하게 정리한 것이라 생각 했습니다.

### models/MasterDao.js

> BackEnd 파트에 MasterDao.js 파일 중 `getMasters` 함수입니다.
>
> 고수 리스트를 출력하는 쿼리에 필터 기능과 무한스크롤을 고려하여 만들었습니다.
>
> 필터 기능은 지역, 카테고리 2개의 타입이 존재하고 지역 필터를 하고 카테고리 필터는 지정을 안하는 등 3가지의 조건 연산자가 필요합니다.
>
> 그래서 `if`문으로 나누었고 중복코드를 없애기 위해서 `data` 라는 리터럴 객체를 선언하여 조건문에 일치한 내부에 필요한 쿼리문을 담았습니다.
>
> 만일 사용자가 필터 기능을 사용하지 않았다면, `if`문을 타지않고 내려가서 바로 `return` 하게 됩니다.

```js
const getMasters = async (search) => {
  const { addressId, lessonId, take } = search;
  let data = {};
  data = {
    take: Number(take),
    select: {
      id: true,
      name: true,
      intro: true,
      master_image: true,
      reviews: {
        select: {
          id: true,
          comment: true,
          grade: true,
          users: {
            select: {
              id: true,
              name: true,
            },
          },
        },
      },
    },
  };

  if (addressId !== "null" && lessonId !== "null") {
    data.where = {
      detailAddress: {
        id: Number(addressId),
      },
      mastersCategories: {
        some: {
          lessonCategories: {
            id: Number(lessonId),
          },
        },
      },
    };
  } else if (addressId !== "null" && lessonId === "null") {
    data.where = {
      detailAddress: {
        id: Number(addressId),
      },
    };
  } else if (addressId === "null" && lessonId !== "null") {
    data.where = {
      mastersCategories: {
        some: {
          lessonCategories: {
            id: Number(lessonId),
          },
        },
      },
    };
  }
  return await prisma.masters.findMany(data);
};
```

# 5프로젝트 보완점

> 보완점은 이번 프로젝트를 진행 하면서 생겨난 불편한 점과 아쉬웠던 점을 정리했습니다.

### 절대경로 설정하기

> 백엔드 서버는 .env 파일을 쉽게 사용했지만, 프론트는 어떠한 문제 때문인지 .evn 파일이 먹지 않았습니다.
>
> 그래서 일단 진행을 하였지만 프론트 코드에 이미지를 사용할 때 상대경로를 사용하거나 IP가 그대로 작성되어 있는 것이 눈에 많이 거슬렸습니다.
>
> 그래서 나중에 프론트에도 .env 파일을 잘 적용해서 해결하게 되었습니다.
>
> 또한 import 파일에 상대경로입니다.
>
> 유지보수를 위해서는 import 파일에 경로를 절대경로로 설정하면 좋을 것 같습니다.

### 프론트 API 응답 테스트

> 이 말은, 프론트 개발자가 UI 설계를 마친 후 백엔드에서 데이터를 화면에 출력할 때 예외처리를 말합니다.
>
> NULL 값이 허용된 데이터가 있다면 어떻게 대처할 것인지, 에러는 나지 않는지, 화면이 비정상적으로 보이진 않는지를 테스트 해야됩니다.
>
> 그래서 데이터를 NOT NULL 컬럼에만 채워놓은 데이터와 컬럼을 전부 채운 데이터 2개로 테스트를 하면 추후에 코드를 수정할 필요없이 응답받은 코드를 바로 적용할 수 있을 것 같습니다.

### 백엔드 콘솔

> API 통신간에 에러는 자주 있는 일입니다.
>
> 하지만 현재 저희들은 어디서 에러가 나는지 바로 찾을 수 가 없습니다.
>
> 왜냐면 콘솔 허용을 금지해서 위치를 알려주는 콘솔을 작성해 놓을 수가 없었습니다.
>
> 그래서 저희는 일일히 위치에 콘솔을 찍어보고 다시 실행하는 수고를 더합니다.
>
> 하지만 현재위치 (controller, service, model)과 함수명을 넣어서 콘솔을 찍어주는 함수를 만들어서 모든 함수에 적용한다면 깔끔하게 현재 위치와 에러난 위치를 빠르게 알 수 있지 않을까 싶습니다.

### 컴포넌트 이동 간 field 이름

> 컴포넌트를 하위로 props를 보내는 상황에서 보내는 값의 이름과 props 받는 이름을 동일하게 적용한다면 보내는 값의 이름이 변경되거나 하위 컴포넌트를 다른곳에서도 사용한다면 햇갈리고 불편하다 생각 했습니다.

```js
// before : user 변수를 선언하고 하위 컴포넌트에 동일한 필드명으로 내려보낸다.
const Parent = () => {
  const user = "seongho";
  return <Children user={user} />;
};
const Children = (props) => {
  const { user } = props;
  return { user };
};

// after : user 변수지만 하위 컴포넌트는 다른 필드명으로 받는것이 컴포넌트 재사용시 가독성이 좋고 상위 컴포넌트도 user 변수를 바꾸게 되도 하위 컴포넌트 필드명을 바꿀 필요가 없다.
const Parent = () => {
  const user = "seongho";
  return <Children value={user} />;
};
const Children = (props) => {
  const { value } = props;
  return { value };
};
```

# 6프로젝트를 마친 후

> 사실 이전 국비교육과 직장에서 프로젝트는 여러번 진행 해봤습니다.
>
> 하지만 이전과 다른 한가지가 있다면, 프로젝트의 모든 것을 온전히 저의 것으로 만들었다는 것 입니다.
>
> 아무것도 모르던 국비교육때와 첫 실무를 겪은 직장에서는 코드를 치는 것에 급했고 실무를 할땐 경험이 늘어나지만 이해할 수 없는 범위가 너무 컸습니다.
>
> 그런 두리뭉실한 지식으로 위코드에 들어와 기본기를 잡아가고 개념을 이해하면서 어느새 부터 컴퓨터적 사고를 하게 되었고 시야가 밝아진 것 같습니다.
>
> 그 덕분에 프로젝트 시작 전부터 자신감이 있었고 설렘이 가득 했습니다.
>
> 프로젝트가 시작하자 마자 노션 템플릿을 만들고 관리 목록을 꾸려나가면서 자연스럽게 팀 내에서 전체적인 관리를 맡게된 것 같습니다.
>
> 프로젝트를 단단하게 만들기 위해 팀 내에 규칙을 정하고 이행하는 것을 보면서 우리들의 작품이 안정적으로 차곡차곡 잘 쌓여가는 느낌이 들었습니다.
>
> 그러던 어느 날 첫번째 스프린트 미팅, 일주일 단위로 나눠 목요일에 미팅을 진행 하는데 개발 일정의 차질과 여러 이슈 사항이 있었고 한번 정신이 번쩍 들었습니다..
>
> 일주일 동안 팀원들이 저의 의견을 많이 들어주셨는데 다음주 까지 개발완료를 못할 것 같은 기분이 들면서 제 탓이라고 생각이 들었습니다.
>
> 다행이 스프린트 미팅때 인지를 해서 기간이 부족한 팀원들의 개발 항목을 나누고 2차 개발 목표에서 3차 목표로 변경한 사항들도 있었습니다.
>
> 그렇게 다행히 결과물을 완성 했던 것 같습니다.
>
> 2주간의 짧은 시간이였지만, 프로젝트 관리를 자처 했던 탓인지 모든 정신을 이 곳에 쏟아 부었던 것 같습니다.
>
> 프로젝트 관리물 최신화, 형상관리, 팀원간에 코드리뷰, 미팅들, 컨벤션 등..어느하나 소홀히 하지 않았다고 자부할 수 있습니다.
>
> 저에게는 그런 점이 화려한 기능을 만드는 것보다 훨씬 뿌듯한 것 같습니다.
>
> 짧지만 지금까지의 경험을 더해서 감히 저만의 개발 신념을 말하자면, 기술적인 테크닉도 물론 중요하지만 한 사람의 존재가 협업에서 시너지를 증폭 시키는 것 이라고 생각 합니다.
>
> 각자의 중요한 역할이 있지만 기획, 개발, 모든 커뮤니티에서 다리 역할이 되어주며 서비스의 방향성을 잃지 않고 단단한 결과물을 만들어 내도록 이끌어갈 수 있는 사람이라 생각합니다.
>
> 그런 사람이 되고 싶고 그걸 위해서 경험, 소통, 테크닉, 관찰 능력을 앞으로도 개발을 하면서 계속해서 키울 것 입니다.
